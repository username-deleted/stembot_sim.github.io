<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: difflib.SequenceMatcher Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacedifflib.html">difflib</a></li><li class="navelem"><a class="el" href="classdifflib_1_1_sequence_matcher.html">SequenceMatcher</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classdifflib_1_1_sequence_matcher-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">difflib.SequenceMatcher Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab9e5a22b040804307bd0efb259e59e81"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdifflib_1_1_sequence_matcher.html#ab9e5a22b040804307bd0efb259e59e81">__init__</a> (self, isjunk=None, a='', b='', autojunk=True)</td></tr>
<tr class="separator:ab9e5a22b040804307bd0efb259e59e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09528f67115537fce036ae50f5872155"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdifflib_1_1_sequence_matcher.html#a09528f67115537fce036ae50f5872155">set_seqs</a> (self, a, b)</td></tr>
<tr class="separator:a09528f67115537fce036ae50f5872155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8a07ababb5fa166fee467f171af59c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdifflib_1_1_sequence_matcher.html#a9d8a07ababb5fa166fee467f171af59c">set_seq1</a> (self, a)</td></tr>
<tr class="separator:a9d8a07ababb5fa166fee467f171af59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9657383200962322b2895a092de1466"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdifflib_1_1_sequence_matcher.html#ae9657383200962322b2895a092de1466">set_seq2</a> (self, b)</td></tr>
<tr class="separator:ae9657383200962322b2895a092de1466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b9d7844837f3e26ac898f5664c307e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdifflib_1_1_sequence_matcher.html#ab2b9d7844837f3e26ac898f5664c307e">find_longest_match</a> (self, alo, ahi, blo, bhi)</td></tr>
<tr class="separator:ab2b9d7844837f3e26ac898f5664c307e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fbaf3fb9f9ec92d96e13d6364cc5104"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdifflib_1_1_sequence_matcher.html#a3fbaf3fb9f9ec92d96e13d6364cc5104">get_matching_blocks</a> (self)</td></tr>
<tr class="separator:a3fbaf3fb9f9ec92d96e13d6364cc5104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3fe02d6f125d74ce31b1e9f8895fc03"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdifflib_1_1_sequence_matcher.html#ae3fe02d6f125d74ce31b1e9f8895fc03">get_opcodes</a> (self)</td></tr>
<tr class="separator:ae3fe02d6f125d74ce31b1e9f8895fc03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6dabd803d4b07d9304351529fd0ef7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdifflib_1_1_sequence_matcher.html#a0b6dabd803d4b07d9304351529fd0ef7">get_grouped_opcodes</a> (self, n=3)</td></tr>
<tr class="separator:a0b6dabd803d4b07d9304351529fd0ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc205b3ab91387b6ec279ce2efd54ef8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdifflib_1_1_sequence_matcher.html#acc205b3ab91387b6ec279ce2efd54ef8">ratio</a> (self)</td></tr>
<tr class="separator:acc205b3ab91387b6ec279ce2efd54ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55e909db0c1821893746dac57a0c41c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdifflib_1_1_sequence_matcher.html#ae55e909db0c1821893746dac57a0c41c">quick_ratio</a> (self)</td></tr>
<tr class="separator:ae55e909db0c1821893746dac57a0c41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef23784ab43fa149c0655ce915885fdc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdifflib_1_1_sequence_matcher.html#aef23784ab43fa149c0655ce915885fdc">real_quick_ratio</a> (self)</td></tr>
<tr class="separator:aef23784ab43fa149c0655ce915885fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a3e8eedf044f3931010959b27aab224dc"><td class="memItemLeft" align="right" valign="top"><a id="a3e8eedf044f3931010959b27aab224dc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>isjunk</b></td></tr>
<tr class="separator:a3e8eedf044f3931010959b27aab224dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf1f29f922e7840431dd0eafbdacc17"><td class="memItemLeft" align="right" valign="top"><a id="aebf1f29f922e7840431dd0eafbdacc17"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>a</b></td></tr>
<tr class="separator:aebf1f29f922e7840431dd0eafbdacc17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ac8ce409f23fb0460e4c6deba89e67"><td class="memItemLeft" align="right" valign="top"><a id="a62ac8ce409f23fb0460e4c6deba89e67"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>b</b></td></tr>
<tr class="separator:a62ac8ce409f23fb0460e4c6deba89e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21adbb8276637b723894e6261f4babad"><td class="memItemLeft" align="right" valign="top"><a id="a21adbb8276637b723894e6261f4babad"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>autojunk</b></td></tr>
<tr class="separator:a21adbb8276637b723894e6261f4babad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1cf07576881c74f9d59a0028ad1077"><td class="memItemLeft" align="right" valign="top"><a id="ada1cf07576881c74f9d59a0028ad1077"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>matching_blocks</b></td></tr>
<tr class="separator:ada1cf07576881c74f9d59a0028ad1077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2827a5a44d729034b8b6c198b87ce9dd"><td class="memItemLeft" align="right" valign="top"><a id="a2827a5a44d729034b8b6c198b87ce9dd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>opcodes</b></td></tr>
<tr class="separator:a2827a5a44d729034b8b6c198b87ce9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f724c13595becc8ec3fd57fc52b0bed"><td class="memItemLeft" align="right" valign="top"><a id="a1f724c13595becc8ec3fd57fc52b0bed"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>fullbcount</b></td></tr>
<tr class="separator:a1f724c13595becc8ec3fd57fc52b0bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e58dcf93fdc9ed1472b19558efc4189"><td class="memItemLeft" align="right" valign="top"><a id="a1e58dcf93fdc9ed1472b19558efc4189"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>b2j</b></td></tr>
<tr class="separator:a1e58dcf93fdc9ed1472b19558efc4189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65fea73ae0b47e03b71bf8a32904c6e"><td class="memItemLeft" align="right" valign="top"><a id="ab65fea73ae0b47e03b71bf8a32904c6e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>isbjunk</b></td></tr>
<tr class="separator:ab65fea73ae0b47e03b71bf8a32904c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78fd8223784f58b314f5c53f5c15458"><td class="memItemLeft" align="right" valign="top"><a id="af78fd8223784f58b314f5c53f5c15458"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>isbpopular</b></td></tr>
<tr class="separator:af78fd8223784f58b314f5c53f5c15458"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">SequenceMatcher is a flexible class for comparing pairs of sequences of
any type, so long as the sequence elements are hashable.  The basic
algorithm predates, and is a little fancier than, an algorithm
published in the late 1980's by Ratcliff and Obershelp under the
hyperbolic name "gestalt pattern matching".  The basic idea is to find
the longest contiguous matching subsequence that contains no "junk"
elements (R-O doesn't address junk).  The same idea is then applied
recursively to the pieces of the sequences to the left and to the right
of the matching subsequence.  This does not yield minimal edit
sequences, but does tend to yield matches that "look right" to people.

SequenceMatcher tries to compute a "human-friendly diff" between two
sequences.  Unlike e.g. UNIX(tm) diff, the fundamental notion is the
longest *contiguous* &amp; junk-free matching subsequence.  That's what
catches peoples' eyes.  The Windows(tm) windiff has another interesting
notion, pairing up elements that appear uniquely in each sequence.
That, and the method here, appear to yield more intuitive difference
reports than does diff.  This method appears to be the least vulnerable
to synching up on blocks of "junk lines", though (like blank lines in
ordinary text files, or maybe "&lt;P&gt;" lines in HTML files).  That may be
because this is the only method of the 3 that has a *concept* of
"junk" &lt;wink&gt;.

Example, comparing two strings, and considering blanks to be "junk":

&gt;&gt;&gt; s = SequenceMatcher(lambda x: x == " ",
...                     "private Thread currentThread;",
...                     "private volatile Thread currentThread;")
&gt;&gt;&gt;

.ratio() returns a float in [0, 1], measuring the "similarity" of the
sequences.  As a rule of thumb, a .ratio() value over 0.6 means the
sequences are close matches:

&gt;&gt;&gt; print round(s.ratio(), 3)
0.866
&gt;&gt;&gt;

If you're only interested in where the sequences match,
.get_matching_blocks() is handy:

&gt;&gt;&gt; for block in s.get_matching_blocks():
...     print "a[%d] and b[%d] match for %d elements" % block
a[0] and b[0] match for 8 elements
a[8] and b[17] match for 21 elements
a[29] and b[38] match for 0 elements

Note that the last tuple returned by .get_matching_blocks() is always a
dummy, (len(a), len(b), 0), and this is the only case in which the last
tuple element (number of elements matched) is 0.

If you want to know how to change the first sequence into the second,
use .get_opcodes():

&gt;&gt;&gt; for opcode in s.get_opcodes():
...     print "%6s a[%d:%d] b[%d:%d]" % opcode
 equal a[0:8] b[0:8]
insert a[8:8] b[8:17]
 equal a[8:29] b[17:38]

See the Differ class for a fancy human-friendly file differencer, which
uses SequenceMatcher both to compare sequences of lines, and to compare
sequences of characters within similar (near-matching) lines.

See also function get_close_matches() in this module, which shows how
simple code building on SequenceMatcher can be used to do useful work.

Timing:  Basic R-O is cubic time worst case and quadratic time expected
case.  SequenceMatcher is quadratic time for the worst case and has
expected-case behavior dependent in a complicated way on how many
elements the sequences have in common; best case time is linear.

Methods:

__init__(isjunk=None, a='', b='')
    Construct a SequenceMatcher.

set_seqs(a, b)
    Set the two sequences to be compared.

set_seq1(a)
    Set the first sequence to be compared.

set_seq2(b)
    Set the second sequence to be compared.

find_longest_match(alo, ahi, blo, bhi)
    Find longest matching block in a[alo:ahi] and b[blo:bhi].

get_matching_blocks()
    Return list of triples describing matching subsequences.

get_opcodes()
    Return list of 5-tuples describing how to turn a into b.

ratio()
    Return a measure of the sequences' similarity (float in [0,1]).

quick_ratio()
    Return an upper bound on .ratio() relatively quickly.

real_quick_ratio()
    Return an upper bound on ratio() very quickly.
</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab9e5a22b040804307bd0efb259e59e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9e5a22b040804307bd0efb259e59e81">&#9670;&nbsp;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def difflib.SequenceMatcher.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>isjunk</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em> = <code>''</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em> = <code>''</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>autojunk</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Construct a SequenceMatcher.

Optional arg isjunk is None (the default), or a one-argument
function that takes a sequence element and returns true iff the
element is junk.  None is equivalent to passing "lambda x: 0", i.e.
no elements are considered to be junk.  For example, pass
    lambda x: x in " \\t"
if you're comparing lines as sequences of characters, and don't
want to synch up on blanks or hard tabs.

Optional arg a is the first of two sequences to be compared.  By
default, an empty string.  The elements of a must be hashable.  See
also .set_seqs() and .set_seq1().

Optional arg b is the second of two sequences to be compared.  By
default, an empty string.  The elements of b must be hashable. See
also .set_seqs() and .set_seq2().

Optional arg autojunk should be set to False to disable the
"automatic junk heuristic" that treats popular elements as junk
(see module documentation for more information).
</pre> 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab2b9d7844837f3e26ac898f5664c307e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b9d7844837f3e26ac898f5664c307e">&#9670;&nbsp;</a></span>find_longest_match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def difflib.SequenceMatcher.find_longest_match </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ahi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>blo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bhi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find longest matching block in a[alo:ahi] and b[blo:bhi].

If isjunk is not defined:

Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where
    alo &lt;= i &lt;= i+k &lt;= ahi
    blo &lt;= j &lt;= j+k &lt;= bhi
and for all (i',j',k') meeting those conditions,
    k &gt;= k'
    i &lt;= i'
    and if i == i', j &lt;= j'

In other words, of all maximal matching blocks, return one that
starts earliest in a, and of all those maximal matching blocks that
start earliest in a, return the one that starts earliest in b.

&gt;&gt;&gt; s = SequenceMatcher(None, " abcd", "abcd abcd")
&gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)
Match(a=0, b=4, size=5)

If isjunk is defined, first the longest matching block is
determined as above, but with the additional restriction that no
junk element appears in the block.  Then that block is extended as
far as possible by matching (only) junk elements on both sides.  So
the resulting block never matches on junk except as identical junk
happens to be adjacent to an "interesting" match.

Here's the same example as before, but considering blanks to be
junk.  That prevents " abcd" from matching the " abcd" at the tail
end of the second sequence directly.  Instead only the "abcd" can
match, and matches the leftmost "abcd" in the second sequence:

&gt;&gt;&gt; s = SequenceMatcher(lambda x: x==" ", " abcd", "abcd abcd")
&gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)
Match(a=1, b=0, size=4)

If no blocks match, return (alo, blo, 0).

&gt;&gt;&gt; s = SequenceMatcher(None, "ab", "c")
&gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)
Match(a=0, b=0, size=0)
</pre> 
</div>
</div>
<a id="a0b6dabd803d4b07d9304351529fd0ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b6dabd803d4b07d9304351529fd0ef7">&#9670;&nbsp;</a></span>get_grouped_opcodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def difflib.SequenceMatcher.get_grouped_opcodes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Isolate change clusters by eliminating ranges with no changes.

Return a generator of groups with up to n lines of context.
Each group is in the same format as returned by get_opcodes().

&gt;&gt;&gt; from pprint import pprint
&gt;&gt;&gt; a = map(str, range(1,40))
&gt;&gt;&gt; b = a[:]
&gt;&gt;&gt; b[8:8] = ['i']     # Make an insertion
&gt;&gt;&gt; b[20] += 'x'       # Make a replacement
&gt;&gt;&gt; b[23:28] = []      # Make a deletion
&gt;&gt;&gt; b[30] += 'y'       # Make another replacement
&gt;&gt;&gt; pprint(list(SequenceMatcher(None,a,b).get_grouped_opcodes()))
[[('equal', 5, 8, 5, 8), ('insert', 8, 8, 8, 9), ('equal', 8, 11, 9, 12)],
 [('equal', 16, 19, 17, 20),
  ('replace', 19, 20, 20, 21),
  ('equal', 20, 22, 21, 23),
  ('delete', 22, 27, 23, 23),
  ('equal', 27, 30, 23, 26)],
 [('equal', 31, 34, 27, 30),
  ('replace', 34, 35, 30, 31),
  ('equal', 35, 38, 31, 34)]]
</pre> 
</div>
</div>
<a id="a3fbaf3fb9f9ec92d96e13d6364cc5104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fbaf3fb9f9ec92d96e13d6364cc5104">&#9670;&nbsp;</a></span>get_matching_blocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def difflib.SequenceMatcher.get_matching_blocks </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return list of triples describing matching subsequences.

Each triple is of the form (i, j, n), and means that
a[i:i+n] == b[j:j+n].  The triples are monotonically increasing in
i and in j.  New in Python 2.5, it's also guaranteed that if
(i, j, n) and (i', j', n') are adjacent triples in the list, and
the second is not the last triple in the list, then i+n != i' or
j+n != j'.  IOW, adjacent triples never describe adjacent equal
blocks.

The last triple is a dummy, (len(a), len(b), 0), and is the only
triple with n==0.

&gt;&gt;&gt; s = SequenceMatcher(None, "abxcd", "abcd")
&gt;&gt;&gt; s.get_matching_blocks()
[Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)]
</pre> 
</div>
</div>
<a id="ae3fe02d6f125d74ce31b1e9f8895fc03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3fe02d6f125d74ce31b1e9f8895fc03">&#9670;&nbsp;</a></span>get_opcodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def difflib.SequenceMatcher.get_opcodes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return list of 5-tuples describing how to turn a into b.

Each tuple is of the form (tag, i1, i2, j1, j2).  The first tuple
has i1 == j1 == 0, and remaining tuples have i1 == the i2 from the
tuple preceding it, and likewise for j1 == the previous j2.

The tags are strings, with these meanings:

'replace':  a[i1:i2] should be replaced by b[j1:j2]
'delete':   a[i1:i2] should be deleted.
            Note that j1==j2 in this case.
'insert':   b[j1:j2] should be inserted at a[i1:i1].
            Note that i1==i2 in this case.
'equal':    a[i1:i2] == b[j1:j2]

&gt;&gt;&gt; a = "qabxcd"
&gt;&gt;&gt; b = "abycdf"
&gt;&gt;&gt; s = SequenceMatcher(None, a, b)
&gt;&gt;&gt; for tag, i1, i2, j1, j2 in s.get_opcodes():
...    print ("%7s a[%d:%d] (%s) b[%d:%d] (%s)" %
...           (tag, i1, i2, a[i1:i2], j1, j2, b[j1:j2]))
 delete a[0:1] (q) b[0:0] ()
  equal a[1:3] (ab) b[0:2] (ab)
replace a[3:4] (x) b[2:3] (y)
  equal a[4:6] (cd) b[3:5] (cd)
 insert a[6:6] () b[5:6] (f)
</pre> 
</div>
</div>
<a id="ae55e909db0c1821893746dac57a0c41c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae55e909db0c1821893746dac57a0c41c">&#9670;&nbsp;</a></span>quick_ratio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def difflib.SequenceMatcher.quick_ratio </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return an upper bound on ratio() relatively quickly.

This isn't defined beyond that it is an upper bound on .ratio(), and
is faster to compute.
</pre> 
</div>
</div>
<a id="acc205b3ab91387b6ec279ce2efd54ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc205b3ab91387b6ec279ce2efd54ef8">&#9670;&nbsp;</a></span>ratio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def difflib.SequenceMatcher.ratio </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a measure of the sequences' similarity (float in [0,1]).

Where T is the total number of elements in both sequences, and
M is the number of matches, this is 2.0*M / T.
Note that this is 1 if the sequences are identical, and 0 if
they have nothing in common.

.ratio() is expensive to compute if you haven't already computed
.get_matching_blocks() or .get_opcodes(), in which case you may
want to try .quick_ratio() or .real_quick_ratio() first to get an
upper bound.

&gt;&gt;&gt; s = SequenceMatcher(None, "abcd", "bcde")
&gt;&gt;&gt; s.ratio()
0.75
&gt;&gt;&gt; s.quick_ratio()
0.75
&gt;&gt;&gt; s.real_quick_ratio()
1.0
</pre> 
</div>
</div>
<a id="aef23784ab43fa149c0655ce915885fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef23784ab43fa149c0655ce915885fdc">&#9670;&nbsp;</a></span>real_quick_ratio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def difflib.SequenceMatcher.real_quick_ratio </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return an upper bound on ratio() very quickly.

This isn't defined beyond that it is an upper bound on .ratio(), and
is faster to compute than either .ratio() or .quick_ratio().
</pre> 
</div>
</div>
<a id="a9d8a07ababb5fa166fee467f171af59c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d8a07ababb5fa166fee467f171af59c">&#9670;&nbsp;</a></span>set_seq1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def difflib.SequenceMatcher.set_seq1 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Set the first sequence to be compared.

The second sequence to be compared is not changed.

&gt;&gt;&gt; s = SequenceMatcher(None, "abcd", "bcde")
&gt;&gt;&gt; s.ratio()
0.75
&gt;&gt;&gt; s.set_seq1("bcde")
&gt;&gt;&gt; s.ratio()
1.0
&gt;&gt;&gt;

SequenceMatcher computes and caches detailed information about the
second sequence, so if you want to compare one sequence S against
many sequences, use .set_seq2(S) once and call .set_seq1(x)
repeatedly for each of the other sequences.

See also set_seqs() and set_seq2().
</pre> 
</div>
</div>
<a id="ae9657383200962322b2895a092de1466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9657383200962322b2895a092de1466">&#9670;&nbsp;</a></span>set_seq2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def difflib.SequenceMatcher.set_seq2 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Set the second sequence to be compared.

The first sequence to be compared is not changed.

&gt;&gt;&gt; s = SequenceMatcher(None, "abcd", "bcde")
&gt;&gt;&gt; s.ratio()
0.75
&gt;&gt;&gt; s.set_seq2("abcd")
&gt;&gt;&gt; s.ratio()
1.0
&gt;&gt;&gt;

SequenceMatcher computes and caches detailed information about the
second sequence, so if you want to compare one sequence S against
many sequences, use .set_seq2(S) once and call .set_seq1(x)
repeatedly for each of the other sequences.

See also set_seqs() and set_seq1().
</pre> 
</div>
</div>
<a id="a09528f67115537fce036ae50f5872155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09528f67115537fce036ae50f5872155">&#9670;&nbsp;</a></span>set_seqs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def difflib.SequenceMatcher.set_seqs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Set the two sequences to be compared.

&gt;&gt;&gt; s = SequenceMatcher()
&gt;&gt;&gt; s.set_seqs("abcd", "bcde")
&gt;&gt;&gt; s.ratio()
0.75
</pre> 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/kiome/Documents/Unity Projects/SIMBoT2021/Assets/Python/Lib/difflib.py</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
