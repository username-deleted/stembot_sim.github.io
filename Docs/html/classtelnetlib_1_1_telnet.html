<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: telnetlib.Telnet Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetelnetlib.html">telnetlib</a></li><li class="navelem"><a class="el" href="classtelnetlib_1_1_telnet.html">Telnet</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classtelnetlib_1_1_telnet-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">telnetlib.Telnet Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8dd0a1589f676f40e3468ab222e30da9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtelnetlib_1_1_telnet.html#a8dd0a1589f676f40e3468ab222e30da9">__init__</a> (self, host=None, port=0, timeout=socket._GLOBAL_DEFAULT_TIMEOUT)</td></tr>
<tr class="separator:a8dd0a1589f676f40e3468ab222e30da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ba2015f7774a67bcd43adc0ff3c51f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtelnetlib_1_1_telnet.html#a72ba2015f7774a67bcd43adc0ff3c51f">open</a> (self, host, port=0, timeout=socket._GLOBAL_DEFAULT_TIMEOUT)</td></tr>
<tr class="separator:a72ba2015f7774a67bcd43adc0ff3c51f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ee796ef302e8beea459b53795e56ef"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtelnetlib_1_1_telnet.html#a40ee796ef302e8beea459b53795e56ef">__del__</a> (self)</td></tr>
<tr class="separator:a40ee796ef302e8beea459b53795e56ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4cb4e2459471897349b306a57002c6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtelnetlib_1_1_telnet.html#a9e4cb4e2459471897349b306a57002c6">msg</a> (self, msg, *args)</td></tr>
<tr class="separator:a9e4cb4e2459471897349b306a57002c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78482abb61dfb071e9ab7bf36d3090df"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtelnetlib_1_1_telnet.html#a78482abb61dfb071e9ab7bf36d3090df">set_debuglevel</a> (self, debuglevel)</td></tr>
<tr class="separator:a78482abb61dfb071e9ab7bf36d3090df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad86e7c778fd875bda0a302e09654714"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtelnetlib_1_1_telnet.html#aad86e7c778fd875bda0a302e09654714">close</a> (self)</td></tr>
<tr class="separator:aad86e7c778fd875bda0a302e09654714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446a91b6fe09b5d28447346598cd23d0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtelnetlib_1_1_telnet.html#a446a91b6fe09b5d28447346598cd23d0">get_socket</a> (self)</td></tr>
<tr class="separator:a446a91b6fe09b5d28447346598cd23d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b542fadd5e9d351ba0d0ac53c04179"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtelnetlib_1_1_telnet.html#a40b542fadd5e9d351ba0d0ac53c04179">fileno</a> (self)</td></tr>
<tr class="separator:a40b542fadd5e9d351ba0d0ac53c04179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab355759db1f776abfc4eddd9be70076c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtelnetlib_1_1_telnet.html#ab355759db1f776abfc4eddd9be70076c">write</a> (self, buffer)</td></tr>
<tr class="separator:ab355759db1f776abfc4eddd9be70076c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fac8cec88316ec86fd08c083c4dfcf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtelnetlib_1_1_telnet.html#ad2fac8cec88316ec86fd08c083c4dfcf">read_until</a> (self, match, timeout=None)</td></tr>
<tr class="separator:ad2fac8cec88316ec86fd08c083c4dfcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb196f7061bba785cadbe4b2f37585d9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtelnetlib_1_1_telnet.html#aeb196f7061bba785cadbe4b2f37585d9">read_all</a> (self)</td></tr>
<tr class="separator:aeb196f7061bba785cadbe4b2f37585d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a1479cc75d82a199ac33bd1e83d98f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtelnetlib_1_1_telnet.html#a50a1479cc75d82a199ac33bd1e83d98f">read_some</a> (self)</td></tr>
<tr class="separator:a50a1479cc75d82a199ac33bd1e83d98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae738a3c7a49b7d8b5c716ca8ceba4fe7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtelnetlib_1_1_telnet.html#ae738a3c7a49b7d8b5c716ca8ceba4fe7">read_very_eager</a> (self)</td></tr>
<tr class="separator:ae738a3c7a49b7d8b5c716ca8ceba4fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5590a11b7a1f637b3585dd166423087a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtelnetlib_1_1_telnet.html#a5590a11b7a1f637b3585dd166423087a">read_eager</a> (self)</td></tr>
<tr class="separator:a5590a11b7a1f637b3585dd166423087a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e58a9773bda80f5488d9216715600a7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtelnetlib_1_1_telnet.html#a7e58a9773bda80f5488d9216715600a7">read_lazy</a> (self)</td></tr>
<tr class="separator:a7e58a9773bda80f5488d9216715600a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bed1f8206e9cdbb6e395cef450781e5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtelnetlib_1_1_telnet.html#a8bed1f8206e9cdbb6e395cef450781e5">read_very_lazy</a> (self)</td></tr>
<tr class="separator:a8bed1f8206e9cdbb6e395cef450781e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b38b4641553a1113b4caa93a4be53c5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtelnetlib_1_1_telnet.html#a1b38b4641553a1113b4caa93a4be53c5">read_sb_data</a> (self)</td></tr>
<tr class="separator:a1b38b4641553a1113b4caa93a4be53c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6f4c1828176d3ea5d385dcb38bab79"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtelnetlib_1_1_telnet.html#a8e6f4c1828176d3ea5d385dcb38bab79">set_option_negotiation_callback</a> (self, callback)</td></tr>
<tr class="separator:a8e6f4c1828176d3ea5d385dcb38bab79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8049490bfbce8cd33bfe7c2358e896"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtelnetlib_1_1_telnet.html#afc8049490bfbce8cd33bfe7c2358e896">process_rawq</a> (self)</td></tr>
<tr class="separator:afc8049490bfbce8cd33bfe7c2358e896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9669d212fb0308c1f123b606f6218b5e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtelnetlib_1_1_telnet.html#a9669d212fb0308c1f123b606f6218b5e">rawq_getchar</a> (self)</td></tr>
<tr class="separator:a9669d212fb0308c1f123b606f6218b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1acbf02e520d66b1d54a1c664488e3a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtelnetlib_1_1_telnet.html#aa1acbf02e520d66b1d54a1c664488e3a">fill_rawq</a> (self)</td></tr>
<tr class="separator:aa1acbf02e520d66b1d54a1c664488e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfc46f989fe1fc6120b7c948b53ac1d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtelnetlib_1_1_telnet.html#a0cfc46f989fe1fc6120b7c948b53ac1d">sock_avail</a> (self)</td></tr>
<tr class="separator:a0cfc46f989fe1fc6120b7c948b53ac1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000328a41c266488ba132f0c69037424"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtelnetlib_1_1_telnet.html#a000328a41c266488ba132f0c69037424">interact</a> (self)</td></tr>
<tr class="separator:a000328a41c266488ba132f0c69037424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9861b30363f83729592292bf6cf5473a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtelnetlib_1_1_telnet.html#a9861b30363f83729592292bf6cf5473a">mt_interact</a> (self)</td></tr>
<tr class="separator:a9861b30363f83729592292bf6cf5473a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a085747a65caa3fb8781d332fdd8d80"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtelnetlib_1_1_telnet.html#a5a085747a65caa3fb8781d332fdd8d80">listener</a> (self)</td></tr>
<tr class="separator:a5a085747a65caa3fb8781d332fdd8d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dbb6ffd6c71355c00121976eef32041"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtelnetlib_1_1_telnet.html#a4dbb6ffd6c71355c00121976eef32041">expect</a> (self, list, timeout=None)</td></tr>
<tr class="separator:a4dbb6ffd6c71355c00121976eef32041"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ae1faa9826fb6edcde49dabe0038103c2"><td class="memItemLeft" align="right" valign="top"><a id="ae1faa9826fb6edcde49dabe0038103c2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>debuglevel</b></td></tr>
<tr class="separator:ae1faa9826fb6edcde49dabe0038103c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5d7f97b245143f309afd64a02a4b53"><td class="memItemLeft" align="right" valign="top"><a id="a1b5d7f97b245143f309afd64a02a4b53"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>host</b></td></tr>
<tr class="separator:a1b5d7f97b245143f309afd64a02a4b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc27f73324dc904aff5e2ee0002fa523"><td class="memItemLeft" align="right" valign="top"><a id="adc27f73324dc904aff5e2ee0002fa523"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>port</b></td></tr>
<tr class="separator:adc27f73324dc904aff5e2ee0002fa523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6348ea4bb2aa2b293403f62f831cf64a"><td class="memItemLeft" align="right" valign="top"><a id="a6348ea4bb2aa2b293403f62f831cf64a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>timeout</b></td></tr>
<tr class="separator:a6348ea4bb2aa2b293403f62f831cf64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f0dcf8fc94128a14df487921e275ff"><td class="memItemLeft" align="right" valign="top"><a id="ab6f0dcf8fc94128a14df487921e275ff"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>sock</b></td></tr>
<tr class="separator:ab6f0dcf8fc94128a14df487921e275ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1320c2a21feccab8ac34074ffd274f"><td class="memItemLeft" align="right" valign="top"><a id="a3c1320c2a21feccab8ac34074ffd274f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>rawq</b></td></tr>
<tr class="separator:a3c1320c2a21feccab8ac34074ffd274f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429f2d33fd47730e2159c67aeb7e22d3"><td class="memItemLeft" align="right" valign="top"><a id="a429f2d33fd47730e2159c67aeb7e22d3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>irawq</b></td></tr>
<tr class="separator:a429f2d33fd47730e2159c67aeb7e22d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98d0168dc29e14b4939cc1fc432535f"><td class="memItemLeft" align="right" valign="top"><a id="af98d0168dc29e14b4939cc1fc432535f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>cookedq</b></td></tr>
<tr class="separator:af98d0168dc29e14b4939cc1fc432535f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeabdb9dfefcfab9f0c4e0a2e51f1d4c6"><td class="memItemLeft" align="right" valign="top"><a id="aeabdb9dfefcfab9f0c4e0a2e51f1d4c6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>eof</b></td></tr>
<tr class="separator:aeabdb9dfefcfab9f0c4e0a2e51f1d4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330a3c020851583d197fa4425396064d"><td class="memItemLeft" align="right" valign="top"><a id="a330a3c020851583d197fa4425396064d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>iacseq</b></td></tr>
<tr class="separator:a330a3c020851583d197fa4425396064d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4042bffe0aca7e53ce023172be57df9"><td class="memItemLeft" align="right" valign="top"><a id="ac4042bffe0aca7e53ce023172be57df9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>sb</b></td></tr>
<tr class="separator:ac4042bffe0aca7e53ce023172be57df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f7c1ace91dbc14b2d3054131ad88e1"><td class="memItemLeft" align="right" valign="top"><a id="aa2f7c1ace91dbc14b2d3054131ad88e1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>sbdataq</b></td></tr>
<tr class="separator:aa2f7c1ace91dbc14b2d3054131ad88e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a307b245a9bb1dadd132dda3b689fd395"><td class="memItemLeft" align="right" valign="top"><a id="a307b245a9bb1dadd132dda3b689fd395"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>option_callback</b></td></tr>
<tr class="separator:a307b245a9bb1dadd132dda3b689fd395"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Telnet interface class.

An instance of this class represents a connection to a telnet
server.  The instance is initially not connected; the open()
method must be used to establish a connection.  Alternatively, the
host name and optional port number can be passed to the
constructor, too.

Don't try to reopen an already connected instance.

This class has many read_*() methods.  Note that some of them
raise EOFError when the end of the connection is read, because
they can return an empty string for other reasons.  See the
individual doc strings.

read_until(expected, [timeout])
    Read until the expected string has been seen, or a timeout is
    hit (default is no timeout); may block.

read_all()
    Read all data until EOF; may block.

read_some()
    Read at least one byte or EOF; may block.

read_very_eager()
    Read all data available already queued or on the socket,
    without blocking.

read_eager()
    Read either data already queued or some data available on the
    socket, without blocking.

read_lazy()
    Read all data in the raw queue (processing it first), without
    doing any socket I/O.

read_very_lazy()
    Reads all data in the cooked queue, without doing any socket
    I/O.

read_sb_data()
    Reads available data between SB ... SE sequence. Don't block.

set_option_negotiation_callback(callback)
    Each time a telnet option is read on the input flow, this callback
    (if set) is called with the following parameters :
    callback(telnet socket, command, option)
        option will be chr(0) when there is no option.
    No other action is done afterwards by telnetlib.</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8dd0a1589f676f40e3468ab222e30da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd0a1589f676f40e3468ab222e30da9">&#9670;&nbsp;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def telnetlib.Telnet.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>host</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>port</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>socket._GLOBAL_DEFAULT_TIMEOUT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Constructor.

When called without arguments, create an unconnected instance.
With a hostname argument, it connects the instance; port number
and timeout are optional.
</pre> 
</div>
</div>
<a id="a40ee796ef302e8beea459b53795e56ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ee796ef302e8beea459b53795e56ef">&#9670;&nbsp;</a></span>__del__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def telnetlib.Telnet.__del__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Destructor -- close the connection.</pre> 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aad86e7c778fd875bda0a302e09654714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad86e7c778fd875bda0a302e09654714">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def telnetlib.Telnet.close </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Close the connection.</pre> 
</div>
</div>
<a id="a4dbb6ffd6c71355c00121976eef32041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dbb6ffd6c71355c00121976eef32041">&#9670;&nbsp;</a></span>expect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def telnetlib.Telnet.expect </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read until one from a list of a regular expressions matches.

The first argument is a list of regular expressions, either
compiled (re.RegexObject instances) or uncompiled (strings).
The optional second argument is a timeout, in seconds; default
is no timeout.

Return a tuple of three items: the index in the list of the
first regular expression that matches; the match object
returned; and the text read up till and including the match.

If EOF is read and no text was read, raise EOFError.
Otherwise, when nothing matches, return (-1, None, text) where
text is the text received so far (may be the empty string if a
timeout happened).

If a regular expression ends with a greedy match (e.g. '.*')
or if more than one expression can match the same input, the
results are undeterministic, and may depend on the I/O timing.</pre> 
</div>
</div>
<a id="a40b542fadd5e9d351ba0d0ac53c04179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b542fadd5e9d351ba0d0ac53c04179">&#9670;&nbsp;</a></span>fileno()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def telnetlib.Telnet.fileno </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the fileno() of the socket object used internally.</pre> 
</div>
</div>
<a id="aa1acbf02e520d66b1d54a1c664488e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1acbf02e520d66b1d54a1c664488e3a">&#9670;&nbsp;</a></span>fill_rawq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def telnetlib.Telnet.fill_rawq </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Fill raw queue from exactly one recv() system call.

Block if no data is immediately available.  Set self.eof when
connection is closed.</pre> 
</div>
</div>
<a id="a446a91b6fe09b5d28447346598cd23d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446a91b6fe09b5d28447346598cd23d0">&#9670;&nbsp;</a></span>get_socket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def telnetlib.Telnet.get_socket </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the socket object used internally.</pre> 
</div>
</div>
<a id="a000328a41c266488ba132f0c69037424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a000328a41c266488ba132f0c69037424">&#9670;&nbsp;</a></span>interact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def telnetlib.Telnet.interact </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Interaction function, emulates a very dumb telnet client.</pre> 
</div>
</div>
<a id="a5a085747a65caa3fb8781d332fdd8d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a085747a65caa3fb8781d332fdd8d80">&#9670;&nbsp;</a></span>listener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def telnetlib.Telnet.listener </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper for mt_interact() -- this executes in the other thread.</pre> 
</div>
</div>
<a id="a9e4cb4e2459471897349b306a57002c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4cb4e2459471897349b306a57002c6">&#9670;&nbsp;</a></span>msg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def telnetlib.Telnet.msg </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Print a debug message, when the debug level is &gt; 0.

If extra arguments are present, they are substituted in the
message using the standard string formatting operator.</pre> 
</div>
</div>
<a id="a9861b30363f83729592292bf6cf5473a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9861b30363f83729592292bf6cf5473a">&#9670;&nbsp;</a></span>mt_interact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def telnetlib.Telnet.mt_interact </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Multithreaded version of interact().</pre> 
</div>
</div>
<a id="a72ba2015f7774a67bcd43adc0ff3c51f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72ba2015f7774a67bcd43adc0ff3c51f">&#9670;&nbsp;</a></span>open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def telnetlib.Telnet.open </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>port</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>socket._GLOBAL_DEFAULT_TIMEOUT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Connect to a host.

The optional second argument is the port number, which
defaults to the standard telnet port (23).

Don't try to reopen an already connected instance.
</pre> 
</div>
</div>
<a id="afc8049490bfbce8cd33bfe7c2358e896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8049490bfbce8cd33bfe7c2358e896">&#9670;&nbsp;</a></span>process_rawq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def telnetlib.Telnet.process_rawq </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Transfer from raw queue to cooked queue.

Set self.eof when connection is closed.  Don't block unless in
the midst of an IAC sequence.</pre> 
</div>
</div>
<a id="a9669d212fb0308c1f123b606f6218b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9669d212fb0308c1f123b606f6218b5e">&#9670;&nbsp;</a></span>rawq_getchar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def telnetlib.Telnet.rawq_getchar </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get next char from raw queue.

Block if no data is immediately available.  Raise EOFError
when connection is closed.</pre> 
</div>
</div>
<a id="aeb196f7061bba785cadbe4b2f37585d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb196f7061bba785cadbe4b2f37585d9">&#9670;&nbsp;</a></span>read_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def telnetlib.Telnet.read_all </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read all data until EOF; block until connection closed.</pre> 
</div>
</div>
<a id="a5590a11b7a1f637b3585dd166423087a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5590a11b7a1f637b3585dd166423087a">&#9670;&nbsp;</a></span>read_eager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def telnetlib.Telnet.read_eager </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read readily available data.

Raise EOFError if connection closed and no cooked data
available.  Return '' if no cooked data available otherwise.
Don't block unless in the midst of an IAC sequence.</pre> 
</div>
</div>
<a id="a7e58a9773bda80f5488d9216715600a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e58a9773bda80f5488d9216715600a7">&#9670;&nbsp;</a></span>read_lazy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def telnetlib.Telnet.read_lazy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Process and return data that's already in the queues (lazy).

Raise EOFError if connection closed and no data available.
Return '' if no cooked data available otherwise.  Don't block
unless in the midst of an IAC sequence.</pre> 
</div>
</div>
<a id="a1b38b4641553a1113b4caa93a4be53c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b38b4641553a1113b4caa93a4be53c5">&#9670;&nbsp;</a></span>read_sb_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def telnetlib.Telnet.read_sb_data </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return any data available in the SB ... SE queue.

Return '' if no SB ... SE available. Should only be called
after seeing a SB or SE command. When a new SB command is
found, old unread SB data will be discarded. Don't block.</pre> 
</div>
</div>
<a id="a50a1479cc75d82a199ac33bd1e83d98f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a1479cc75d82a199ac33bd1e83d98f">&#9670;&nbsp;</a></span>read_some()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def telnetlib.Telnet.read_some </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read at least one byte of cooked data unless EOF is hit.

Return '' if EOF is hit.  Block if no data is immediately
available.</pre> 
</div>
</div>
<a id="ad2fac8cec88316ec86fd08c083c4dfcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2fac8cec88316ec86fd08c083c4dfcf">&#9670;&nbsp;</a></span>read_until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def telnetlib.Telnet.read_until </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read until a given string is encountered or until timeout.

When no match is found, return whatever is available instead,
possibly the empty string.  Raise EOFError if the connection
is closed and no cooked data is available.</pre> 
</div>
</div>
<a id="ae738a3c7a49b7d8b5c716ca8ceba4fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae738a3c7a49b7d8b5c716ca8ceba4fe7">&#9670;&nbsp;</a></span>read_very_eager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def telnetlib.Telnet.read_very_eager </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read everything that's possible without blocking in I/O (eager).

Raise EOFError if connection closed and no cooked data
available.  Return '' if no cooked data available otherwise.
Don't block unless in the midst of an IAC sequence.</pre> 
</div>
</div>
<a id="a8bed1f8206e9cdbb6e395cef450781e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bed1f8206e9cdbb6e395cef450781e5">&#9670;&nbsp;</a></span>read_very_lazy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def telnetlib.Telnet.read_very_lazy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return any data available in the cooked queue (very lazy).

Raise EOFError if connection closed and no data available.
Return '' if no cooked data available otherwise.  Don't block.</pre> 
</div>
</div>
<a id="a78482abb61dfb071e9ab7bf36d3090df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78482abb61dfb071e9ab7bf36d3090df">&#9670;&nbsp;</a></span>set_debuglevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def telnetlib.Telnet.set_debuglevel </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>debuglevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Set the debug level.

The higher it is, the more debug output you get (on sys.stdout).</pre> 
</div>
</div>
<a id="a8e6f4c1828176d3ea5d385dcb38bab79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6f4c1828176d3ea5d385dcb38bab79">&#9670;&nbsp;</a></span>set_option_negotiation_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def telnetlib.Telnet.set_option_negotiation_callback </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Provide a callback function called after each receipt of a telnet option.</pre> 
</div>
</div>
<a id="a0cfc46f989fe1fc6120b7c948b53ac1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cfc46f989fe1fc6120b7c948b53ac1d">&#9670;&nbsp;</a></span>sock_avail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def telnetlib.Telnet.sock_avail </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Test whether data is available on the socket.</pre> 
</div>
</div>
<a id="ab355759db1f776abfc4eddd9be70076c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab355759db1f776abfc4eddd9be70076c">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def telnetlib.Telnet.write </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Write a string to the socket, doubling any IAC characters.

Can block if the connection is blocked.  May raise
socket.error if the connection is closed.</pre> 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/kiome/Documents/Unity Projects/SIMBoT2021/Assets/Python/Lib/telnetlib.py</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
