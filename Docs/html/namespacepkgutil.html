<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: pkgutil Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">pkgutil Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpkgutil_1_1_imp_importer.html">ImpImporter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpkgutil_1_1_imp_loader.html">ImpLoader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aea477cd13557cb841a5ed916b2d125ca"><td class="memItemLeft" align="right" valign="top"><a id="aea477cd13557cb841a5ed916b2d125ca"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>read_code</b> (stream)</td></tr>
<tr class="separator:aea477cd13557cb841a5ed916b2d125ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2082046c2694eed331a3c56da2e68a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepkgutil.html#abe2082046c2694eed331a3c56da2e68a">simplegeneric</a> (func)</td></tr>
<tr class="separator:abe2082046c2694eed331a3c56da2e68a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91fa9f8d57fda7f95b51c6dbca5ba76"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepkgutil.html#aa91fa9f8d57fda7f95b51c6dbca5ba76">walk_packages</a> (path=None, prefix='', onerror=None)</td></tr>
<tr class="separator:aa91fa9f8d57fda7f95b51c6dbca5ba76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10636b23ee372ecc68bfe6921a4d9118"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepkgutil.html#a10636b23ee372ecc68bfe6921a4d9118">iter_modules</a> (path=None, prefix='')</td></tr>
<tr class="separator:a10636b23ee372ecc68bfe6921a4d9118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b83121b6ed40f0317749a1d747ca5fe"><td class="memItemLeft" align="right" valign="top"><a id="a9b83121b6ed40f0317749a1d747ca5fe"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>iter_importer_modules</b> (importer, prefix='')</td></tr>
<tr class="separator:a9b83121b6ed40f0317749a1d747ca5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3cb5095205b573da0705c846779d1f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepkgutil.html#a9d3cb5095205b573da0705c846779d1f">get_importer</a> (path_item)</td></tr>
<tr class="separator:a9d3cb5095205b573da0705c846779d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5003f7434a537a771f34e21242d00275"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepkgutil.html#a5003f7434a537a771f34e21242d00275">iter_importers</a> (fullname=&quot;&quot;)</td></tr>
<tr class="separator:a5003f7434a537a771f34e21242d00275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cb0e56ce3f49ebe02034d52751e762"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepkgutil.html#aa2cb0e56ce3f49ebe02034d52751e762">get_loader</a> (module_or_name)</td></tr>
<tr class="separator:aa2cb0e56ce3f49ebe02034d52751e762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f435e9b185c41ca64b1845d1798d934"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepkgutil.html#a4f435e9b185c41ca64b1845d1798d934">find_loader</a> (fullname)</td></tr>
<tr class="separator:a4f435e9b185c41ca64b1845d1798d934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7dbab9fc00071906128a3f6e90dabf0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepkgutil.html#ae7dbab9fc00071906128a3f6e90dabf0">extend_path</a> (path, name)</td></tr>
<tr class="separator:ae7dbab9fc00071906128a3f6e90dabf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99f4741fc4427cf8839a21199b1a94b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepkgutil.html#ac99f4741fc4427cf8839a21199b1a94b">get_data</a> (package, resource)</td></tr>
<tr class="separator:ac99f4741fc4427cf8839a21199b1a94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab7af3ccf4d0ca8c406a2cbfc2bdf157f"><td class="memItemLeft" align="right" valign="top"><a id="ab7af3ccf4d0ca8c406a2cbfc2bdf157f"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>iter_importer_modules</b> = <a class="el" href="namespacepkgutil.html#abe2082046c2694eed331a3c56da2e68a">simplegeneric</a>(iter_importer_modules)</td></tr>
<tr class="separator:ab7af3ccf4d0ca8c406a2cbfc2bdf157f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Utilities to support packages.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="ae7dbab9fc00071906128a3f6e90dabf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7dbab9fc00071906128a3f6e90dabf0">&#9670;&nbsp;</a></span>extend_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pkgutil.extend_path </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Extend a package's path.

Intended use is to place the following code in a package's __init__.py:

    from pkgutil import extend_path
    __path__ = extend_path(__path__, __name__)

This will add to the package's __path__ all subdirectories of
directories on sys.path named after the package.  This is useful
if one wants to distribute different parts of a single logical
package as multiple directories.

It also looks for *.pkg files beginning where * matches the name
argument.  This feature is similar to *.pth files (see site.py),
except that it doesn't special-case lines starting with 'import'.
A *.pkg file is trusted at face value: apart from checking for
duplicates, all entries found in a *.pkg file are added to the
path, regardless of whether they are exist the filesystem.  (This
is a feature.)

If the input path is not a list (as is the case for frozen
packages) it is returned unchanged.  The input path is not
modified; an extended copy is returned.  Items are only appended
to the copy at the end.

It is assumed that sys.path is a sequence.  Items of sys.path that
are not (unicode or 8-bit) strings referring to existing
directories are ignored.  Unicode items of sys.path that cause
errors when used as filenames may cause this function to raise an
exception (in line with os.path.isdir() behavior).
</pre> 
</div>
</div>
<a id="a4f435e9b185c41ca64b1845d1798d934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f435e9b185c41ca64b1845d1798d934">&#9670;&nbsp;</a></span>find_loader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pkgutil.find_loader </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fullname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find a PEP 302 "loader" object for fullname

If fullname contains dots, path must be the containing package's __path__.
Returns None if the module cannot be found or imported. This function uses
iter_importers(), and is thus subject to the same limitations regarding
platform-specific special import locations such as the Windows registry.
</pre> 
</div>
</div>
<a id="ac99f4741fc4427cf8839a21199b1a94b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99f4741fc4427cf8839a21199b1a94b">&#9670;&nbsp;</a></span>get_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pkgutil.get_data </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>package</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>resource</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get a resource from a package.

This is a wrapper round the PEP 302 loader get_data API. The package
argument should be the name of a package, in standard module format
(foo.bar). The resource argument should be in the form of a relative
filename, using '/' as the path separator. The parent directory name '..'
is not allowed, and nor is a rooted name (starting with a '/').

The function returns a binary string, which is the contents of the
specified resource.

For packages located in the filesystem, which have already been imported,
this is the rough equivalent of

    d = os.path.dirname(sys.modules[package].__file__)
    data = open(os.path.join(d, resource), 'rb').read()

If the package cannot be located or loaded, or it uses a PEP 302 loader
which does not support get_data(), then None is returned.
</pre> 
</div>
</div>
<a id="a9d3cb5095205b573da0705c846779d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d3cb5095205b573da0705c846779d1f">&#9670;&nbsp;</a></span>get_importer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pkgutil.get_importer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>path_item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Retrieve a PEP 302 importer for the given path item

The returned importer is cached in sys.path_importer_cache
if it was newly created by a path hook.

If there is no importer, a wrapper around the basic import
machinery is returned. This wrapper is never inserted into
the importer cache (None is inserted instead).

The cache (or part of it) can be cleared manually if a
rescan of sys.path_hooks is necessary.
</pre> 
</div>
</div>
<a id="aa2cb0e56ce3f49ebe02034d52751e762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2cb0e56ce3f49ebe02034d52751e762">&#9670;&nbsp;</a></span>get_loader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pkgutil.get_loader </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>module_or_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get a PEP 302 "loader" object for module_or_name

If the module or package is accessible via the normal import
mechanism, a wrapper around the relevant part of that machinery
is returned.  Returns None if the module cannot be found or imported.
If the named module is not already imported, its containing package
(if any) is imported, in order to establish the package __path__.

This function uses iter_importers(), and is thus subject to the same
limitations regarding platform-specific special import locations such
as the Windows registry.
</pre> 
</div>
</div>
<a id="a5003f7434a537a771f34e21242d00275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5003f7434a537a771f34e21242d00275">&#9670;&nbsp;</a></span>iter_importers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pkgutil.iter_importers </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fullname</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield PEP 302 importers for the given module name

If fullname contains a '.', the importers will be for the package
containing fullname, otherwise they will be importers for sys.meta_path,
sys.path, and Python's "classic" import machinery, in that order.  If
the named module is in a package, that package is imported as a side
effect of invoking this function.

Non PEP 302 mechanisms (e.g. the Windows registry) used by the
standard import machinery to find files in alternative locations
are partially supported, but are searched AFTER sys.path. Normally,
these locations are searched BEFORE sys.path, preventing sys.path
entries from shadowing them.

For this to cause a visible difference in behaviour, there must
be a module or package name that is accessible via both sys.path
and one of the non PEP 302 file system mechanisms. In this case,
the emulation will find the former version, while the builtin
import mechanism will find the latter.

Items of the following types can be affected by this discrepancy:
    imp.C_EXTENSION, imp.PY_SOURCE, imp.PY_COMPILED, imp.PKG_DIRECTORY
</pre> 
</div>
</div>
<a id="a10636b23ee372ecc68bfe6921a4d9118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10636b23ee372ecc68bfe6921a4d9118">&#9670;&nbsp;</a></span>iter_modules()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pkgutil.iter_modules </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>path</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>''</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yields (module_loader, name, ispkg) for all submodules on path,
or, if path is None, all top-level modules on sys.path.

'path' should be either None or a list of paths to look for
modules in.

'prefix' is a string to output on the front of every module name
on output.
</pre> 
</div>
</div>
<a id="abe2082046c2694eed331a3c56da2e68a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe2082046c2694eed331a3c56da2e68a">&#9670;&nbsp;</a></span>simplegeneric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pkgutil.simplegeneric </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Make a trivial single-dispatch generic function</pre> 
</div>
</div>
<a id="aa91fa9f8d57fda7f95b51c6dbca5ba76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa91fa9f8d57fda7f95b51c6dbca5ba76">&#9670;&nbsp;</a></span>walk_packages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pkgutil.walk_packages </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>path</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>''</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>onerror</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yields (module_loader, name, ispkg) for all modules recursively
on path, or, if path is None, all accessible modules.

'path' should be either None or a list of paths to look for
modules in.

'prefix' is a string to output on the front of every module name
on output.

Note that this function must import all *packages* (NOT all
modules!) on the given path, in order to access the __path__
attribute to find submodules.

'onerror' is a function which gets called with one argument (the
name of the package which was being imported) if any exception
occurs while trying to import a package.  If no onerror function is
supplied, ImportErrors are caught and ignored, while all other
exceptions are propagated, terminating the search.

Examples:

# list all modules python can access
walk_packages()

# list all submodules of ctypes
walk_packages(ctypes.__path__, ctypes.__name__+'.')
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
